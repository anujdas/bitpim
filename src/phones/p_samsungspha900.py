# THIS FILE IS AUTOMATICALLY GENERATED.  EDIT THE SOURCE FILE NOT THIS ONE

"""Proposed descriptions of data usign AT commands"""

from prototypes import *
from p_samsung_packet import *
from p_samsungspha620 import *

# We use LSB for all integer like fields in diagnostic mode
UINT=UINTlsb
BOOL=BOOLlsb
#

NUMPHONEBOOKENTRIES=300
NUMEMAILS=3
NUMPHONENUMBERS=6
MAXNUMBERLEN=32
NUMTODOENTRIES=9
NUMSMSENTRIES=94

NUMGROUPS=4

AMSREGISTRY="ams/AmsRegistry"

DEFAULT_RINGTONE=0
DEFAULT_WALLPAPER=0

class numberheader(BaseProtogenClass):
    __fields=['head1', 'head2', 'head3']

    def __init__(self, *args, **kwargs):
        dict={}
        # What was supplied to this function
        dict.update(kwargs)
        # Parent constructor
        super(numberheader,self).__init__(**dict)
        if self.__class__ is numberheader:
            self._update(args,dict)


    def getfields(self):
        return self.__fields


    def _update(self, args, kwargs):
        super(numberheader,self)._update(args,kwargs)
        keys=kwargs.keys()
        for key in keys:
            if key in self.__fields:
                setattr(self, key, kwargs[key])
                del kwargs[key]
        # Were any unrecognized kwargs passed in?
        if __debug__:
            self._complainaboutunusedargs(numberheader,kwargs)
        if len(args): raise TypeError('Unexpected arguments supplied: '+`args`)
        # Make all P fields that haven't already been constructed


    def writetobuffer(self,buf,autolog=True,logtitle="<written data>"):
        'Writes this packet to the supplied buffer'
        self._bufferstartoffset=buf.getcurrentoffset()
        try: self.__field_head1
        except:
            self.__field_head1=UINT(**{'constant': 0x26})
        self.__field_head1.writetobuffer(buf)
        try: self.__field_head2
        except:
            self.__field_head2=UINT(**{'constant': 0x39})
        self.__field_head2.writetobuffer(buf)
        try: self.__field_head3
        except:
            self.__field_head3=UINT(**{'constant': 0x0})
        self.__field_head3.writetobuffer(buf)
        self._bufferendoffset=buf.getcurrentoffset()
        if autolog and self._bufferstartoffset==0: self.autologwrite(buf, logtitle=logtitle)


    def readfrombuffer(self,buf,autolog=True,logtitle="<read data>"):
        'Reads this packet from the supplied buffer'
        self._bufferstartoffset=buf.getcurrentoffset()
        if autolog and self._bufferstartoffset==0: self.autologread(buf, logtitle=logtitle)
        self.__field_head1=UINT(**{'constant': 0x26})
        self.__field_head1.readfrombuffer(buf)
        self.__field_head2=UINT(**{'constant': 0x39})
        self.__field_head2.readfrombuffer(buf)
        self.__field_head3=UINT(**{'constant': 0x0})
        self.__field_head3.readfrombuffer(buf)
        self._bufferendoffset=buf.getcurrentoffset()


    def __getfield_head1(self):
        try: self.__field_head1
        except:
            self.__field_head1=UINT(**{'constant': 0x26})
        return self.__field_head1.getvalue()

    def __setfield_head1(self, value):
        if isinstance(value,UINT):
            self.__field_head1=value
        else:
            self.__field_head1=UINT(value,**{'constant': 0x26})

    def __delfield_head1(self): del self.__field_head1

    head1=property(__getfield_head1, __setfield_head1, __delfield_head1, None)

    def __getfield_head2(self):
        try: self.__field_head2
        except:
            self.__field_head2=UINT(**{'constant': 0x39})
        return self.__field_head2.getvalue()

    def __setfield_head2(self, value):
        if isinstance(value,UINT):
            self.__field_head2=value
        else:
            self.__field_head2=UINT(value,**{'constant': 0x39})

    def __delfield_head2(self): del self.__field_head2

    head2=property(__getfield_head2, __setfield_head2, __delfield_head2, None)

    def __getfield_head3(self):
        try: self.__field_head3
        except:
            self.__field_head3=UINT(**{'constant': 0x0})
        return self.__field_head3.getvalue()

    def __setfield_head3(self, value):
        if isinstance(value,UINT):
            self.__field_head3=value
        else:
            self.__field_head3=UINT(value,**{'constant': 0x0})

    def __delfield_head3(self): del self.__field_head3

    head3=property(__getfield_head3, __setfield_head3, __delfield_head3, None)

    def iscontainer(self):
        return True

    def containerelements(self):
        yield ('head1', self.__field_head1, None)
        yield ('head2', self.__field_head2, None)
        yield ('head3', self.__field_head3, None)




class nameheader(BaseProtogenClass):
    __fields=['head1', 'head2', 'head3']

    def __init__(self, *args, **kwargs):
        dict={}
        # What was supplied to this function
        dict.update(kwargs)
        # Parent constructor
        super(nameheader,self).__init__(**dict)
        if self.__class__ is nameheader:
            self._update(args,dict)


    def getfields(self):
        return self.__fields


    def _update(self, args, kwargs):
        super(nameheader,self)._update(args,kwargs)
        keys=kwargs.keys()
        for key in keys:
            if key in self.__fields:
                setattr(self, key, kwargs[key])
                del kwargs[key]
        # Were any unrecognized kwargs passed in?
        if __debug__:
            self._complainaboutunusedargs(nameheader,kwargs)
        if len(args): raise TypeError('Unexpected arguments supplied: '+`args`)
        # Make all P fields that haven't already been constructed


    def writetobuffer(self,buf,autolog=True,logtitle="<written data>"):
        'Writes this packet to the supplied buffer'
        self._bufferstartoffset=buf.getcurrentoffset()
        try: self.__field_head1
        except:
            self.__field_head1=UINT(**{'constant': 0xd3})
        self.__field_head1.writetobuffer(buf)
        try: self.__field_head2
        except:
            self.__field_head2=UINT(**{'constant': 0x59})
        self.__field_head2.writetobuffer(buf)
        try: self.__field_head3
        except:
            self.__field_head3=UINT(**{'constant': 0x0e})
        self.__field_head3.writetobuffer(buf)
        self._bufferendoffset=buf.getcurrentoffset()
        if autolog and self._bufferstartoffset==0: self.autologwrite(buf, logtitle=logtitle)


    def readfrombuffer(self,buf,autolog=True,logtitle="<read data>"):
        'Reads this packet from the supplied buffer'
        self._bufferstartoffset=buf.getcurrentoffset()
        if autolog and self._bufferstartoffset==0: self.autologread(buf, logtitle=logtitle)
        self.__field_head1=UINT(**{'constant': 0xd3})
        self.__field_head1.readfrombuffer(buf)
        self.__field_head2=UINT(**{'constant': 0x59})
        self.__field_head2.readfrombuffer(buf)
        self.__field_head3=UINT(**{'constant': 0x0e})
        self.__field_head3.readfrombuffer(buf)
        self._bufferendoffset=buf.getcurrentoffset()


    def __getfield_head1(self):
        try: self.__field_head1
        except:
            self.__field_head1=UINT(**{'constant': 0xd3})
        return self.__field_head1.getvalue()

    def __setfield_head1(self, value):
        if isinstance(value,UINT):
            self.__field_head1=value
        else:
            self.__field_head1=UINT(value,**{'constant': 0xd3})

    def __delfield_head1(self): del self.__field_head1

    head1=property(__getfield_head1, __setfield_head1, __delfield_head1, None)

    def __getfield_head2(self):
        try: self.__field_head2
        except:
            self.__field_head2=UINT(**{'constant': 0x59})
        return self.__field_head2.getvalue()

    def __setfield_head2(self, value):
        if isinstance(value,UINT):
            self.__field_head2=value
        else:
            self.__field_head2=UINT(value,**{'constant': 0x59})

    def __delfield_head2(self): del self.__field_head2

    head2=property(__getfield_head2, __setfield_head2, __delfield_head2, None)

    def __getfield_head3(self):
        try: self.__field_head3
        except:
            self.__field_head3=UINT(**{'constant': 0x0e})
        return self.__field_head3.getvalue()

    def __setfield_head3(self, value):
        if isinstance(value,UINT):
            self.__field_head3=value
        else:
            self.__field_head3=UINT(value,**{'constant': 0x0e})

    def __delfield_head3(self): del self.__field_head3

    head3=property(__getfield_head3, __setfield_head3, __delfield_head3, None)

    def iscontainer(self):
        return True

    def containerelements(self):
        yield ('head1', self.__field_head1, None)
        yield ('head2', self.__field_head2, None)
        yield ('head3', self.__field_head3, None)




class numberrequest(BaseProtogenClass):
    __fields=['header', 'slot', 'pad']

    def __init__(self, *args, **kwargs):
        dict={}
        # What was supplied to this function
        dict.update(kwargs)
        # Parent constructor
        super(numberrequest,self).__init__(**dict)
        if self.__class__ is numberrequest:
            self._update(args,dict)


    def getfields(self):
        return self.__fields


    def _update(self, args, kwargs):
        super(numberrequest,self)._update(args,kwargs)
        keys=kwargs.keys()
        for key in keys:
            if key in self.__fields:
                setattr(self, key, kwargs[key])
                del kwargs[key]
        # Were any unrecognized kwargs passed in?
        if __debug__:
            self._complainaboutunusedargs(numberrequest,kwargs)
        if len(args): raise TypeError('Unexpected arguments supplied: '+`args`)
        # Make all P fields that haven't already been constructed


    def writetobuffer(self,buf,autolog=True,logtitle="<written data>"):
        'Writes this packet to the supplied buffer'
        self._bufferstartoffset=buf.getcurrentoffset()
        self.__field_header.writetobuffer(buf)
        self.__field_slot.writetobuffer(buf)
        self.__field_pad.writetobuffer(buf)
        self._bufferendoffset=buf.getcurrentoffset()
        if autolog and self._bufferstartoffset==0: self.autologwrite(buf, logtitle=logtitle)


    def readfrombuffer(self,buf,autolog=True,logtitle="<read data>"):
        'Reads this packet from the supplied buffer'
        self._bufferstartoffset=buf.getcurrentoffset()
        if autolog and self._bufferstartoffset==0: self.autologread(buf, logtitle=logtitle)
        self.__field_header=numberheader()
        self.__field_header.readfrombuffer(buf)
        self.__field_slot=UINT(**{'sizeinbytes': 2})
        self.__field_slot.readfrombuffer(buf)
        self.__field_pad=UNKNOWN(**{'sizeinbytes': 128})
        self.__field_pad.readfrombuffer(buf)
        self._bufferendoffset=buf.getcurrentoffset()


    def __getfield_header(self):
        return self.__field_header.getvalue()

    def __setfield_header(self, value):
        if isinstance(value,numberheader):
            self.__field_header=value
        else:
            self.__field_header=numberheader(value,)

    def __delfield_header(self): del self.__field_header

    header=property(__getfield_header, __setfield_header, __delfield_header, None)

    def __getfield_slot(self):
        return self.__field_slot.getvalue()

    def __setfield_slot(self, value):
        if isinstance(value,UINT):
            self.__field_slot=value
        else:
            self.__field_slot=UINT(value,**{'sizeinbytes': 2})

    def __delfield_slot(self): del self.__field_slot

    slot=property(__getfield_slot, __setfield_slot, __delfield_slot, None)

    def __getfield_pad(self):
        return self.__field_pad.getvalue()

    def __setfield_pad(self, value):
        if isinstance(value,UNKNOWN):
            self.__field_pad=value
        else:
            self.__field_pad=UNKNOWN(value,**{'sizeinbytes': 128})

    def __delfield_pad(self): del self.__field_pad

    pad=property(__getfield_pad, __setfield_pad, __delfield_pad, None)

    def iscontainer(self):
        return True

    def containerelements(self):
        yield ('header', self.__field_header, None)
        yield ('slot', self.__field_slot, None)
        yield ('pad', self.__field_pad, None)




class numberresponse(BaseProtogenClass):
    __fields=['header', 'pad1', 'numlen', 'num']

    def __init__(self, *args, **kwargs):
        dict={}
        # What was supplied to this function
        dict.update(kwargs)
        # Parent constructor
        super(numberresponse,self).__init__(**dict)
        if self.__class__ is numberresponse:
            self._update(args,dict)


    def getfields(self):
        return self.__fields


    def _update(self, args, kwargs):
        super(numberresponse,self)._update(args,kwargs)
        keys=kwargs.keys()
        for key in keys:
            if key in self.__fields:
                setattr(self, key, kwargs[key])
                del kwargs[key]
        # Were any unrecognized kwargs passed in?
        if __debug__:
            self._complainaboutunusedargs(numberresponse,kwargs)
        if len(args): raise TypeError('Unexpected arguments supplied: '+`args`)
        # Make all P fields that haven't already been constructed


    def writetobuffer(self,buf,autolog=True,logtitle="<written data>"):
        'Writes this packet to the supplied buffer'
        self._bufferstartoffset=buf.getcurrentoffset()
        self.__field_header.writetobuffer(buf)
        self.__field_pad1.writetobuffer(buf)
        self.__field_numlen.writetobuffer(buf)
        self.__field_num.writetobuffer(buf)
        self._bufferendoffset=buf.getcurrentoffset()
        if autolog and self._bufferstartoffset==0: self.autologwrite(buf, logtitle=logtitle)


    def readfrombuffer(self,buf,autolog=True,logtitle="<read data>"):
        'Reads this packet from the supplied buffer'
        self._bufferstartoffset=buf.getcurrentoffset()
        if autolog and self._bufferstartoffset==0: self.autologread(buf, logtitle=logtitle)
        self.__field_header=numberheader()
        self.__field_header.readfrombuffer(buf)
        self.__field_pad1=UINT(**{'sizeinbytes': 5})
        self.__field_pad1.readfrombuffer(buf)
        self.__field_numlen=UINT(**{'sizeinbytes': 1})
        self.__field_numlen.readfrombuffer(buf)
        self.__field_num=USTRING(**{'sizeinbytes': 48, 'raiseonunterminatedread': False})
        self.__field_num.readfrombuffer(buf)
        self._bufferendoffset=buf.getcurrentoffset()


    def __getfield_header(self):
        return self.__field_header.getvalue()

    def __setfield_header(self, value):
        if isinstance(value,numberheader):
            self.__field_header=value
        else:
            self.__field_header=numberheader(value,)

    def __delfield_header(self): del self.__field_header

    header=property(__getfield_header, __setfield_header, __delfield_header, None)

    def __getfield_pad1(self):
        return self.__field_pad1.getvalue()

    def __setfield_pad1(self, value):
        if isinstance(value,UINT):
            self.__field_pad1=value
        else:
            self.__field_pad1=UINT(value,**{'sizeinbytes': 5})

    def __delfield_pad1(self): del self.__field_pad1

    pad1=property(__getfield_pad1, __setfield_pad1, __delfield_pad1, None)

    def __getfield_numlen(self):
        return self.__field_numlen.getvalue()

    def __setfield_numlen(self, value):
        if isinstance(value,UINT):
            self.__field_numlen=value
        else:
            self.__field_numlen=UINT(value,**{'sizeinbytes': 1})

    def __delfield_numlen(self): del self.__field_numlen

    numlen=property(__getfield_numlen, __setfield_numlen, __delfield_numlen, None)

    def __getfield_num(self):
        return self.__field_num.getvalue()

    def __setfield_num(self, value):
        if isinstance(value,USTRING):
            self.__field_num=value
        else:
            self.__field_num=USTRING(value,**{'sizeinbytes': 48, 'raiseonunterminatedread': False})

    def __delfield_num(self): del self.__field_num

    num=property(__getfield_num, __setfield_num, __delfield_num, None)

    def iscontainer(self):
        return True

    def containerelements(self):
        yield ('header', self.__field_header, None)
        yield ('pad1', self.__field_pad1, None)
        yield ('numlen', self.__field_numlen, None)
        yield ('num', self.__field_num, None)




