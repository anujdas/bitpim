### (-*- python -*-)
### A python wrapper for the libusb 1.x library
### (c) 2010 Nathan Hjelm <hjelmn@users.sourceforge.net>
### (c) Bitpim
###
### This code is in the Public Domain.  (libusb is released under the LGPL)
###
###

import sys
import os
from ctypes import *

if sys.platform == 'darwin':
    try:
        path = str.join ('/', os.environ['RESOURCEPATH'].split('/')[:-1]) + '/Frameworks/'
    except:
        path = "/opt/local/lib/"
    libusb = CDLL(path + "libusb-1.0.dylib")
else:
    libusb = CDLL("libusb-1.0.so")

class libusb_device_descriptor(Structure):
    _fields_ = [("bLength", c_uint8), ("bDescriptorType", c_uint8), ("bcdUSB", c_uint16),
                ("bDeviceClass", c_uint8), ("bDeviceSubClass", c_uint8), ("bDeviceProtocol", c_uint8),
                ("bMaxPacketSize0", c_uint8), ("idVendor", c_uint16), ("idProduct", c_uint16),
                ("bcdDevice", c_uint16), ("iManufacturer", c_uint8), ("iProduct", c_uint8),
                ("iSerialNumber", c_uint8), ("bNumConfigurations", c_uint8)]

class libusb_endpoint_descriptor(Structure):
    _fields_ = [("bLength", c_uint8), ("bDescriptorType", c_uint8), ("bEndpointAddress", c_uint8),
                ("bmAttributes", c_uint8), ("wMaxPacketSize", c_uint16), ("bInterval", c_uint8),
                ("bRefresh", c_uint8), ("bSyncAddress", c_uint8), ("extra", c_char_p),
                ("extra_length", c_int)]

class libusb_interface_descriptor(Structure):
    _fields_ = [("bLength", c_uint8), ("bDescriptorType", c_uint8), ("bInterfaceNumber", c_uint8),
                ("bAlternateSetting", c_uint8), ("bNumEndpoints", c_uint8), ("bInterfaceClass", c_uint8),
                ("bInterfaceSubClass", c_uint8), ("bInterfaceProtocol", c_uint8), ("iInterface", c_uint8),
                ("endpoint", POINTER(libusb_endpoint_descriptor)), ("extra", c_char_p), ("extra_length", c_int)]

class libusb_interface(Structure):
    _fields_ = [("altsetting", POINTER(libusb_interface_descriptor)), ("num_altsetting", c_int)]

class libusb_config_descriptor (Structure):
    _fields_ = [("bLength", c_uint8), ("bDescriptorType", c_uint8), ("wTotalLength", c_uint16),
                ("bNumInterfaces", c_uint8), ("bConfigurationValue", c_uint8), ("iConfiguration", c_uint8),
                ("bmAttributes", c_uint8), ("MaxPower", c_uint8), ("interface", POINTER(libusb_interface)),
                ("extra", c_char_p), ("extra_length", c_int)]

TRACE=False

class USBDevice:
    def __init__ (self, dev):
        self.libusb = libusb
        self.dev    = dev
        self.desc   = libusb_device_descriptor ()
        self.pcdesc = pointer(libusb_config_descriptor ())
        libusb.libusb_get_device_descriptor (dev, byref (self.desc))
        libusb.libusb_get_config_descriptor (dev, 0, byref (self.pcdesc))
        self.handle = c_void_p (None)

        ret = libusb.libusb_open (self.dev, byref (self.handle))
        if TRACE: print "libusb_open(%s, %s)=%s" % (self.dev, byref (self.handle), ret)
        if ret < 0:
            raise

    def __del__ (self):
        self.close ()

    def close(self):
        if libusb is not None and self.handle is not None:
            if TRACE: print "libusb_close(%s)" % (self.handle,)
            libusb.libusb_close (self.handle)
            self.handle = None

    def name(self):
        # this name is based off the name generated by usb-0.1
        return "%03i-%04x-%04x-%02x-%02x"%(libusb.libusb_get_device_address (self.dev), self.desc.idVendor, self.desc.idProduct, self.desc.bDeviceClass, self.desc.bDeviceSubClass)

    def busnumber (self):
        return libusb.libusb_get_bus_number(self.dev)

    def vendor(self):
        return self.desc.idVendor

    def product(self):
        return self.desc.idProduct

    def vendorstring(self):
        return self._getstring("iManufacturer")

    def productstring(self):
        return self._getstring("iProduct")

    def serialnumber(self):
        return self._getstring("iSerialNumber")

    def _getstring(self, fieldname):
        n = getattr(self.desc, fieldname)
        if n:
            buffer = create_string_buffer (1024)
            res = libusb.libusb_get_string_descriptor_ascii (self.handle, n, buffer, 1024)
            string = string_at (buffer)
            if TRACE: print "usb_get_string_descriptor_ascii (%s, %d, %s, %d)=%d,%s" % (self.handle, n, buffer, 1024, res, string)
            if res<0:
                raise
            return string
        return None

    def interfaces (self):
        for i in range(self.pcdesc[0].bNumInterfaces):
            yield USBInterface(self, self.pcdesc[0].interface[i])
        raise StopIteration()

    def classdetails(self):
        "returns a tuple of device class, devicesubclass, deviceprotocol (all ints)"
        return self.desc.bDeviceClass, self.desc.bDeviceSubClass, self.desc.bDeviceProtocol

class USBInterface:
    # currently we only deal with first configuration
    def __init__(self, device, iface, alt=None):
        self.iface=iface
        self.device=device
        self.desc=alt or iface.altsetting[0]
        self.isopen = False

    def __del__ (self):
        self.closebulk ()

    def number(self):
        return self.desc.bInterfaceNumber

    def altnumber(self):
        return self.desc.bAlternateSetting

    def classdetails(self):
        return self.desc.bInterfaceClass, self.desc.bInterfaceSubClass, self.desc.bInterfaceProtocol

    def openbulk(self,epinno=None,epoutno=None):
        "Returns a filelike object you can use to read and write"
        # find the endpoints
        match=lambda ep1, ep2: (ep1 is None) or (ep2 is None) or ((ep1 & 0x7f) == (ep2 & 0x7f))

        epin=None
        epout=None
        for ep in self.endpoints():
            if ep.isbulk():
                if ep.direction()==0x80:
                    if (not epin) and match(epinno,ep.address()): epin=ep
                else:
                    if (not epout) and match(epoutno,ep.address()): epout=ep
        assert epin is not None
        assert epout is not None

        # set the configuration
        if TRACE:
            print "getting configvalue"
        v=self.device.pcdesc[0].bConfigurationValue
        if TRACE:
            print "value is",v,"now about to set config"
        res = libusb.libusb_set_configuration(self.device.handle, v)
        if TRACE:
            print "libusb_set_configuration(%s, %d)=%d" % (self.device.handle,v,res)
            print "config set"
            # grab the interface
            print "claiming",self.number()
        res = libusb.libusb_claim_interface (self.device.handle, self.number())
        if TRACE: print "libusb_claim_interface(%s, %d)=%d" % (self.device.handle, self.number(), res)
        if res<0:
            raise USBException()

        # set the alt setting
#        res = libusb.libusb_set_interface_alt_setting (self.device.handle, self.altnumber())
#        if TRACE: print "libusb_set_interface_alt_setting (%s, %d)=%d" % (self.device.handle, self.altnumber(), res)
        if res<0:
            # Setting the alternate interface causes problems with some phones (VX-10000)
            # reset the device and reclaim the interface if there was problem setting the
            # alternate interface.
            libusb.libusb_reset_device (self.device.handle)
            libusb.libusb_release_interface (self.device.handle, self.number())

            res = libusb.libusb_claim_interface(self.device.handle, self.number())
            if res<0:
                raise USBException()

        self.isopen = True

        # we now have the file
        return USBFile(self, epin, epout)

    def closebulk (self):
        if self.isopen:
            libusb.libusb_release_interface (self.device.handle, self.number ())
            self.isopen = False

    def alternates(self):
       for i in range(self.iface.num_altsetting):
           yield USBInterface(self.device,self.iface,usb.usb_interface_descriptor_index(self.iface.altsetting,i))
    # a generator raises its StopIteration() by itself

    def endpoints(self):
       for i in range(self.desc.bNumEndpoints):
           yield USBEndpoint(self.desc.endpoint[i])
       raise StopIteration()

class USBEndpoint:
    def __init__(self, ep):
        self.ep=ep

    def type(self):
        return self.ep.bmAttributes & 0x03

    def address(self):
        return self.ep.bEndpointAddress

    def maxpacketsize(self):
        return self.ep.wMaxPacketSize

    def isbulk(self):
        return self.type() == 2

    def direction(self):
#        assert self.isbulk()
        return self.ep.bEndpointAddress & 0xf0

class USBFile:
    def __init__(self, iface, epin, epout):
        self.iface=iface
        self.epin=epin
        self.epout=epout
        self.addrin=epin.address()
        self.addrout=epout.address()
        self.insize=epin.maxpacketsize()
        self.outsize=epout.maxpacketsize()

    def __del__(self):
        self.resetep ()

    def resetep(self, resetin=True, resetout=True):
        if resetin:
            res = libusb.libusb_clear_halt(self.iface.device.handle, self.addrin)
            if TRACE: print "usb_clear_halt(%s,%d)=%d" % (self.iface.device.handle, self.addrin, res)
        if resetout:
            res = libusb.libusb_clear_halt(self.iface.device.handle, self.addrout)
            if TRACE: print "usb_clear_halt(%s,%d)=%d" % (self.iface.device.handle, self.addrout, res)

    def read(self,howmuch=1024, timeout=1000):
        data=""
        buffer = create_string_buffer (self.insize)
        while howmuch>0:
            readsize = c_int(self.insize)
            res = libusb.libusb_bulk_transfer (self.iface.device.handle, self.addrin, buffer, self.insize, byref (readsize), int(timeout))
            str = string_at (buffer, readsize.value)
            if TRACE: print "libusb_bulk_transfer(%s,%x,%s,%d,%d)=%d,%s" % (self.iface.device.handle, self.addrin, buffer, self.insize, timeout, res, `str`)
            if res<0:
                if len(data)>0:
                    return data
                raise USBException ()
            if readsize.value == 0:
                return data
            data+=str
            howmuch-=len(str)
            if howmuch and len(str)!=self.insize:
                # short read, no more data
                break

        return data

    def write(self, data, timeout=1000):
        first=True
        while first or len(data):
            first=False
            writesize = min(len(data), self.outsize)
            cwritesize = c_int (writesize)
            cdata = create_string_buffer(data[:writesize])
            res = libusb.libusb_bulk_transfer (self.iface.device.handle, self.addrout, cdata, cwritesize, byref (cwritesize), timeout)
            if TRACE: print "libusb_bulk_transfer(%s, %d, %s, %d, %d)=%d" % (self.iface.device.handle, self.addrout, cdata, min(len(data), writesize), timeout, res)
            if res<0:
                raise USBException()
            data=data[cwritesize.value:]

class USBException(Exception):
    def __init__(self):
        Exception.__init__(self, "a usb error occurred")

def OpenDevice(vendorid, productid, interfaceid):
    for device in AllDevices ():
        if device.vendor()==vendorid and device.product()==productid:
            for iface in device.interfaces():
                if iface.number()==interfaceid:
                    return iface.openbulk()
    raise ValueError( "vendor 0x%x product 0x%x interface %d not found" % (vendorid, productid, interfaceid))
        
    
def classtostring(klass):
    "Returns the class as a string"
    for sym in dir(libusb):
        if sym.startswith("USB_CLASS_") and klass==getattr(libusb, sym):
            return sym
    return `klass`

def eptypestring(type):
    for sym in dir(libusb):
        if sym.startswith("TYPE_") and type==getattr(libusb, sym):
            return sym
    return `type`

def AllDevices ():
    ptr = pointer(pointer(c_void_p(None)))
    count = libusb.libusb_get_device_list (None, byref(ptr))
    if count < 0:
        raise

    for i in range(count):
        yield USBDevice (ptr[i])

    libusb.libusb_free_device_list (ptr, 1)
    raise StopIteration ()

import gc

ret = libusb.libusb_init (None)
if ret < 0:
    raise
if __name__=='__main__':
    for device in AllDevices ():
        print "  %x/%x" % (device.vendor(), device.product())
        klass,subclass,proto=device.classdetails()
        print "  class %s subclass %d protocol %d" % (classtostring(klass), subclass, proto)
        print " name %s" % (device.name())
        print " bus number: %i" % (device.busnumber ())
        for i in device.vendorstring, device.productstring, device.serialnumber:
            try:
                print "  "+i()
            except:
                pass
        for iface in device.interfaces():
            print "      interface number %d" % (iface.number(),)
            klass,subclass,proto=iface.classdetails()
            print "      class %s subclass %d protocol %d" % (classtostring(klass), subclass, proto)
            for ep in iface.endpoints():
                print "          endpointaddress 0x%x" % (ep.address(),)
                print "          "+eptypestring(ep.type()),
                if ep.isbulk():
                    if ep.direction()==0x80:
                        print "IN"
                    else:
                        print "OUT"
                else:
                    print
                    
            print ""
        print ""
    print ""

    print "opening device"
    cell=OpenDevice(0x1004, 0x6000, 2)
    print "device opened, about to write"
    cell.write("\x01\xf1\xe1\x7e")
    print "wrote, about to read"
    res=cell.read(12)
    print "read %d bytes" % (len(res),)
    print `res`
#    cell.close()
